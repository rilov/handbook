<h2 id="understanding-file-formats">Understanding File Formats</h2>

<p>Think of file formats as different languages for storing data. Just like you might write a grocery list (simple) or a legal document (structured), different formats serve different purposes.</p>

<div class="mermaid">
flowchart TD
    FILES["üìÅ Data File Formats"]
    
    FILES --&gt; TEXT["üìù Text-Based<br />Human-readable"]
    FILES --&gt; BINARY["‚öôÔ∏è Binary<br />Machine-optimized"]
    FILES --&gt; COMPRESSED["üì¶ Compressed<br />Space-saving"]
    FILES --&gt; TABLE["üóÑÔ∏è Table Formats<br />ACID transactions"]
    
    TEXT --&gt; CSV["CSV, TSV, TXT<br />JSON, XML, YAML"]
    BINARY --&gt; BIG["Parquet, ORC, Avro<br />XLS, XLSX"]
    COMPRESSED --&gt; COMP["GZIP, ZIP, BZIP2"]
    TABLE --&gt; LAKE["Delta Lake<br />Iceberg, Hudi"]
    
    style FILES fill:#dbeafe,stroke:#2563eb
    style TEXT fill:#d1fae5,stroke:#059669
    style BINARY fill:#fef3c7,stroke:#d97706
    style COMPRESSED fill:#fce7f3,stroke:#db2777
    style TABLE fill:#e0e7ff,stroke:#6366f1
</div>

<hr />

<h2 id="text-based-formats-human-readable">Text-Based Formats (Human-Readable)</h2>

<h3 id="csv-comma-separated-values">CSV (Comma-Separated Values)</h3>

<p><strong>What it looks like:</strong></p>
<pre><code class="language-csv">name,age,city
John,25,New York
Jane,30,Los Angeles
Bob,28,Chicago
</code></pre>

<div class="mermaid">
flowchart LR
    subgraph csv["CSV File Structure"]
        H["name,age,city<br />(header)"]
        R1["John,25,New York"]
        R2["Jane,30,Los Angeles"]
        R3["Bob,28,Chicago"]
    end
    
    style H fill:#dbeafe,stroke:#2563eb
    style R1 fill:#d1fae5,stroke:#059669
    style R2 fill:#d1fae5,stroke:#059669
    style R3 fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Simple, universal, opens in Excel</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>No data types, struggles with commas in data</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Small datasets, sharing data</td>
    </tr>
    <tr>
      <td><strong>File Size</strong></td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="tsv-tab-separated-values">TSV (Tab-Separated Values)</h3>

<p><strong>What it looks like:</strong></p>
<pre><code class="language-tsv">name	age	city
John	25	New York
Jane	30	Los Angeles
</code></pre>

<p><strong>Key Difference from CSV:</strong> Uses tabs (<code class="language-plaintext highlighter-rouge">\t</code>) instead of commas, so commas in data don‚Äôt break things.</p>

<table>
  <thead>
    <tr>
      <th>Use TSV When‚Ä¶</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Data contains commas</td>
      <td>Addresses: ‚Äú123 Main St, Apt 4‚Äù</td>
    </tr>
    <tr>
      <td>Exporting from databases</td>
      <td>More reliable than CSV</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="txt-plain-text">TXT (Plain Text)</h3>

<p><strong>What it looks like:</strong></p>
<pre><code class="language-txt">This is just plain text.
No structure, no rules.
Whatever you want to write.
</code></pre>

<p><strong>Real-World Analogy:</strong> Like a notebook ‚Äî write anything, but no organization.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Simplest possible, works anywhere</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>No structure, hard to parse</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Logs, notes, unstructured data</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="json-javascript-object-notation">JSON (JavaScript Object Notation)</h3>

<p><strong>What it looks like:</strong></p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"John"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w">
  </span><span class="nl">"city"</span><span class="p">:</span><span class="w"> </span><span class="s2">"New York"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"hobbies"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"reading"</span><span class="p">,</span><span class="w"> </span><span class="s2">"coding"</span><span class="p">],</span><span class="w">
  </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"street"</span><span class="p">:</span><span class="w"> </span><span class="s2">"123 Main St"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"zip"</span><span class="p">:</span><span class="w"> </span><span class="s2">"10001"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="mermaid">
flowchart TD
    subgraph json["JSON Structure"]
        ROOT["{ }"]
        NAME["name: 'John'"]
        AGE["age: 25"]
        HOBBIES["hobbies: [ ]"]
        H1["reading"]
        H2["coding"]
        ADDRESS["address: { }"]
        STREET["street: '123 Main St'"]
        
        ROOT --&gt; NAME
        ROOT --&gt; AGE
        ROOT --&gt; HOBBIES
        HOBBIES --&gt; H1
        HOBBIES --&gt; H2
        ROOT --&gt; ADDRESS
        ADDRESS --&gt; STREET
    end
    
    style ROOT fill:#dbeafe,stroke:#2563eb
    style HOBBIES fill:#fef3c7,stroke:#d97706
    style ADDRESS fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Flexible, supports nesting, widely used</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>Verbose (lots of brackets), larger files</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>APIs, config files, web applications</td>
    </tr>
    <tr>
      <td><strong>File Size</strong></td>
      <td>Large (human-readable)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="xml-extensible-markup-language">XML (eXtensible Markup Language)</h3>

<p><strong>What it looks like:</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;person&gt;</span>
  <span class="nt">&lt;name&gt;</span>John<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;age&gt;</span>25<span class="nt">&lt;/age&gt;</span>
  <span class="nt">&lt;city&gt;</span>New York<span class="nt">&lt;/city&gt;</span>
  <span class="nt">&lt;hobbies&gt;</span>
    <span class="nt">&lt;hobby&gt;</span>reading<span class="nt">&lt;/hobby&gt;</span>
    <span class="nt">&lt;hobby&gt;</span>coding<span class="nt">&lt;/hobby&gt;</span>
  <span class="nt">&lt;/hobbies&gt;</span>
<span class="nt">&lt;/person&gt;</span>
</code></pre></div></div>

<p><strong>Real-World Analogy:</strong> Like HTML but for data. Very structured, lots of tags.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Strict validation, supports attributes</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>VERY verbose, hard to read</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Enterprise systems, SOAP APIs, legacy systems</td>
    </tr>
    <tr>
      <td><strong>Modern Usage</strong></td>
      <td>Being replaced by JSON</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="yaml-yaml-aint-markup-language">YAML (YAML Ain‚Äôt Markup Language)</h3>

<p><strong>What it looks like:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">John</span>
<span class="na">age</span><span class="pi">:</span> <span class="m">25</span>
<span class="na">city</span><span class="pi">:</span> <span class="s">New York</span>
<span class="na">hobbies</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">reading</span>
  <span class="pi">-</span> <span class="s">coding</span>
<span class="na">address</span><span class="pi">:</span>
  <span class="na">street</span><span class="pi">:</span> <span class="s">123 Main St</span>
  <span class="na">zip</span><span class="pi">:</span> <span class="m">10001</span>
</code></pre></div></div>

<p><strong>Key Feature:</strong> Uses indentation (like Python) instead of brackets.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Very readable, clean, supports comments</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>Whitespace-sensitive (can be fragile)</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Config files (Kubernetes, Docker Compose)</td>
    </tr>
  </tbody>
</table>

<div class="mermaid">
flowchart LR
    subgraph compare["JSON vs YAML vs XML"]
        JSON_["JSON<br />{ 'name': 'John' }"]
        YAML_["YAML<br />name: John"]
        XML_["XML<br />&lt;name&gt;John&lt;/name&gt;"]
    end
    
    JSON_ --&gt; |"Most common"| API["APIs"]
    YAML_ --&gt; |"Most readable"| CONFIG["Config Files"]
    XML_ --&gt; |"Most verbose"| LEGACY["Legacy Systems"]
    
    style JSON_ fill:#dbeafe,stroke:#2563eb
    style YAML_ fill:#d1fae5,stroke:#059669
    style XML_ fill:#fecaca,stroke:#dc2626
</div>

<hr />

<h2 id="spreadsheet-formats">Spreadsheet Formats</h2>

<h3 id="xls-excel-binary-format---old">XLS (Excel Binary Format - Old)</h3>

<p><strong>What it is:</strong> Microsoft Excel‚Äôs old binary format (pre-2007).</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Max Rows</strong></td>
      <td>65,536 (very limited!)</td>
    </tr>
    <tr>
      <td><strong>Max Columns</strong></td>
      <td>256</td>
    </tr>
    <tr>
      <td><strong>Status</strong></td>
      <td>‚ö†Ô∏è Deprecated ‚Äî don‚Äôt use for new projects</td>
    </tr>
    <tr>
      <td><strong>Opens In</strong></td>
      <td>Excel, LibreOffice</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="xlsx-excel-open-xml-format---modern">XLSX (Excel Open XML Format - Modern)</h3>

<p><strong>What it is:</strong> Modern Excel format, actually a ZIP file containing XML files!</p>

<div class="mermaid">
flowchart LR
    XLSX["my-file.xlsx"] --&gt; ZIP["(Actually a ZIP)"]
    ZIP --&gt; XML1["worksheets/sheet1.xml"]
    ZIP --&gt; XML2["styles.xml"]
    ZIP --&gt; XML3["workbook.xml"]
    
    style XLSX fill:#d1fae5,stroke:#059669
    style ZIP fill:#fef3c7,stroke:#d97706
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Max Rows</strong></td>
      <td>1,048,576</td>
    </tr>
    <tr>
      <td><strong>Max Columns</strong></td>
      <td>16,384</td>
    </tr>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Formulas, formatting, multiple sheets</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>Bloated for large data, proprietary</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Business reports, sharing with non-technical users</td>
    </tr>
  </tbody>
</table>

<p><strong>Fun Fact:</strong> Rename <code class="language-plaintext highlighter-rouge">.xlsx</code> to <code class="language-plaintext highlighter-rouge">.zip</code> and unzip it ‚Äî you‚Äôll see the XML files inside!</p>

<hr />

<h2 id="big-data-formats-binary-optimized">Big Data Formats (Binary, Optimized)</h2>

<h3 id="parquet">Parquet</h3>

<p><strong>What it is:</strong> Columnar storage format optimized for analytics.</p>

<div class="mermaid">
flowchart LR
    subgraph csv_storage["Row-Based (CSV)"]
        R1["Row 1: John,25,NYC"]
        R2["Row 2: Jane,30,LA"]
        R3["Row 3: Bob,28,CHI"]
    end
    
    subgraph parquet_storage["Column-Based (Parquet)"]
        C1["Name: John,Jane,Bob"]
        C2["Age: 25,30,28"]
        C3["City: NYC,LA,CHI"]
    end
    
    csv_storage --&gt; |"Slow for analytics"| SLOW["üò∞"]
    parquet_storage --&gt; |"Fast for analytics"| FAST["üöÄ"]
    
    style csv_storage fill:#fecaca,stroke:#dc2626
    style parquet_storage fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Storage</strong></td>
      <td>Columnar (like columnar databases)</td>
    </tr>
    <tr>
      <td><strong>Compression</strong></td>
      <td>Excellent (10x smaller than CSV)</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Very fast for reads</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Data warehouses, analytics, Spark/Hadoop</td>
    </tr>
    <tr>
      <td><strong>Tools</strong></td>
      <td>Spark, Pandas, DuckDB, Snowflake</td>
    </tr>
  </tbody>
</table>

<p><strong>Real-World Analogy:</strong> Instead of reading entire books to find all mentions of ‚Äúdata,‚Äù you have an index that lists every page with ‚Äúdata.‚Äù</p>

<hr />

<h3 id="orc-optimized-row-columnar">ORC (Optimized Row Columnar)</h3>

<p><strong>What it is:</strong> Like Parquet, but optimized for Hive/Hadoop.</p>

<div class="mermaid">
flowchart TD
    ORC["ORC File"]
    
    ORC --&gt; STRIPE1["Stripe 1<br />(10K rows)"]
    ORC --&gt; STRIPE2["Stripe 2<br />(10K rows)"]
    
    STRIPE1 --&gt; INDEX["Index"]
    STRIPE1 --&gt; DATA["Compressed<br />Column Data"]
    STRIPE1 --&gt; FOOTER["Footer<br />(metadata)"]
    
    style ORC fill:#dbeafe,stroke:#2563eb
    style STRIPE1 fill:#d1fae5,stroke:#059669
    style DATA fill:#fef3c7,stroke:#d97706
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Parquet</th>
      <th>ORC</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ecosystem</strong></td>
      <td>Spark, Python</td>
      <td>Hive, Hadoop</td>
    </tr>
    <tr>
      <td><strong>Compression</strong></td>
      <td>Excellent</td>
      <td>Slightly better</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Very fast</td>
      <td>Slightly faster</td>
    </tr>
    <tr>
      <td><strong>Use In</strong></td>
      <td>Most cases</td>
      <td>Hadoop-heavy environments</td>
    </tr>
  </tbody>
</table>

<p><strong>Which to choose?</strong> Use Parquet unless you‚Äôre deep in the Hadoop ecosystem.</p>

<hr />

<h3 id="avro">Avro</h3>

<p><strong>What it is:</strong> Row-based format with embedded schema. Great for streaming.</p>

<p><strong>Example Schema:</strong></p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"record"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"name"</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"age"</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"int"</span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="mermaid">
flowchart LR
    subgraph avro["Avro File"]
        SCHEMA["Schema<br />(JSON)"]
        DATA["Binary Data"]
    end
    
    SCHEMA --&gt; |"Self-describing"| READ["Can always<br />read the file"]
    
    style SCHEMA fill:#dbeafe,stroke:#2563eb
    style DATA fill:#d1fae5,stroke:#059669
    style READ fill:#fef3c7,stroke:#d97706
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Storage</strong></td>
      <td>Row-based (not columnar)</td>
    </tr>
    <tr>
      <td><strong>Schema</strong></td>
      <td>Embedded in file</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Kafka, streaming, evolving schemas</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Fast writes, slower reads than Parquet</td>
    </tr>
  </tbody>
</table>

<p><strong>When to Use:</strong></p>
<ul>
  <li>‚úÖ Kafka / event streaming</li>
  <li>‚úÖ Schema evolution (adding fields over time)</li>
  <li>‚ùå Analytics (use Parquet instead)</li>
</ul>

<hr />

<h2 id="database--serialization-formats">Database &amp; Serialization Formats</h2>

<h3 id="sql-structured-query-language">SQL (Structured Query Language)</h3>

<p><strong>What it is:</strong> A text file with database commands, not a data format itself.</p>

<p><strong>Example:</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">age</span> <span class="nb">INT</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'John'</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">users</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Jane'</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Use Case</strong></td>
      <td>Database exports, backups, migrations</td>
    </tr>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Portable, human-readable</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>Slow for large datasets</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Sharing database structures, small exports</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="pickle-python-serialization">Pickle (Python Serialization)</h3>

<p><strong>What it is:</strong> Python‚Äôs native format for saving Python objects.</p>

<p><strong>Example:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pickle</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">age</span><span class="sh">'</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="sh">'</span><span class="s">hobbies</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">coding</span><span class="sh">'</span><span class="p">]}</span>

<span class="c1"># Save
</span><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">data.pkl</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">wb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">pickle</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="c1"># Load
</span><span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">data.pkl</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<div class="mermaid">
flowchart LR
    PY["Python Object"] --&gt; |"pickle.dump()"| PKL["data.pkl"]
    PKL --&gt; |"pickle.load()"| PY2["Python Object"]
    
    style PY fill:#dbeafe,stroke:#2563eb
    style PKL fill:#fef3c7,stroke:#d97706
    style PY2 fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Pros</strong></td>
      <td>Saves Python objects exactly (lists, dicts, classes)</td>
    </tr>
    <tr>
      <td><strong>Cons</strong></td>
      <td>‚ö†Ô∏è Python-only, security risk (code execution)</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>ML models, temporary Python data</td>
    </tr>
    <tr>
      <td><strong>‚ö†Ô∏è Warning</strong></td>
      <td>Never load untrusted pickle files!</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="compressed-formats">Compressed Formats</h2>

<h3 id="gzip-gz">GZIP (.gz)</h3>

<p><strong>What it is:</strong> Compression algorithm that makes files smaller.</p>

<div class="mermaid">
flowchart LR
    ORIG["data.csv<br />100 MB"] --&gt; |"gzip"| COMP["data.csv.gz<br />10 MB"]
    COMP --&gt; |"gunzip"| ORIG2["data.csv<br />100 MB"]
    
    style ORIG fill:#fecaca,stroke:#dc2626
    style COMP fill:#d1fae5,stroke:#059669
    style ORIG2 fill:#dbeafe,stroke:#2563eb
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Compression Ratio</strong></td>
      <td>~10x smaller</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Fast</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Single files, log files, streaming</td>
    </tr>
    <tr>
      <td><strong>Common Use</strong></td>
      <td><code class="language-plaintext highlighter-rouge">data.csv.gz</code>, <code class="language-plaintext highlighter-rouge">logs.txt.gz</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Example:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Compress</span>
<span class="nb">gzip </span>data.csv  <span class="c"># Creates data.csv.gz</span>

<span class="c"># Decompress</span>
<span class="nb">gunzip </span>data.csv.gz  <span class="c"># Restores data.csv</span>
</code></pre></div></div>

<hr />

<h3 id="zip">ZIP</h3>

<p><strong>What it is:</strong> Archive format that compresses multiple files.</p>

<div class="mermaid">
flowchart TD
    subgraph before["Before Zipping"]
        F1["report.pdf"]
        F2["data.csv"]
        F3["image.png"]
    end
    
    subgraph after["After Zipping"]
        ZIP["archive.zip<br />(all files compressed)"]
    end
    
    F1 --&gt; ZIP
    F2 --&gt; ZIP
    F3 --&gt; ZIP
    
    style before fill:#fecaca,stroke:#dc2626
    style after fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Compression</strong></td>
      <td>Good</td>
    </tr>
    <tr>
      <td><strong>Multiple Files</strong></td>
      <td>‚úÖ Yes (like a folder)</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Sharing multiple files, downloads</td>
    </tr>
    <tr>
      <td><strong>Opens In</strong></td>
      <td>Every OS built-in</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="bzip2-bz2">BZIP2 (.bz2)</h3>

<p><strong>What it is:</strong> Slower compression, but better compression ratio than GZIP.</p>

<table>
  <thead>
    <tr>
      <th>Format</th>
      <th>Compression</th>
      <th>Speed</th>
      <th>Use When</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GZIP</strong></td>
      <td>Good</td>
      <td>Fast</td>
      <td>Default choice</td>
    </tr>
    <tr>
      <td><strong>BZIP2</strong></td>
      <td>Better</td>
      <td>Slower</td>
      <td>Archiving, storage</td>
    </tr>
    <tr>
      <td><strong>ZIP</strong></td>
      <td>Good</td>
      <td>Fast</td>
      <td>Multiple files</td>
    </tr>
  </tbody>
</table>

<p><strong>Real-World Analogy:</strong></p>
<ul>
  <li>GZIP = Quick packing for a trip</li>
  <li>BZIP2 = Carefully vacuum-packing for long-term storage</li>
</ul>

<hr />

<h2 id="table-formats-acid-on-data-lakes">Table Formats (ACID on Data Lakes)</h2>

<p>These formats add <strong>database features</strong> (transactions, versioning, updates) to data lakes.</p>

<div class="mermaid">
flowchart TD
    subgraph traditional["Traditional Data Lake"]
        FILES["Just files<br />(Parquet, CSV)"]
        PROBLEMS["Problems:<br />‚ùå No ACID<br />‚ùå No time travel<br />‚ùå Hard to update"]
    end
    
    subgraph modern["Modern Table Formats"]
        FORMAT["Delta/Iceberg/Hudi"]
        FEATURES["Features:<br />‚úÖ ACID transactions<br />‚úÖ Time travel<br />‚úÖ Schema evolution<br />‚úÖ Easy updates"]
    end
    
    traditional --&gt; |"Upgrade"| modern
    
    style traditional fill:#fecaca,stroke:#dc2626
    style modern fill:#d1fae5,stroke:#059669
</div>

<hr />

<h3 id="delta-lake">Delta Lake</h3>

<p><strong>What it is:</strong> Open format by Databricks. Adds ACID to Parquet files.</p>

<div class="mermaid">
flowchart LR
    subgraph delta["Delta Lake Structure"]
        LOG["_delta_log/<br />(transaction log)"]
        PARQUET["Parquet Files<br />(actual data)"]
    end
    
    LOG --&gt; |"Tracks changes"| PARQUET
    
    style LOG fill:#dbeafe,stroke:#2563eb
    style PARQUET fill:#d1fae5,stroke:#059669
</div>

<p><strong>Features:</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Time travel</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span> <span class="k">VERSION</span> <span class="k">AS</span> <span class="k">OF</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">-- Rollback</span>
<span class="n">RESTORE</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="k">TO</span> <span class="k">VERSION</span> <span class="k">AS</span> <span class="k">OF</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">-- Schema evolution</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">email</span> <span class="n">STRING</span><span class="p">;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ACID</strong></td>
      <td>‚úÖ Full transactions</td>
    </tr>
    <tr>
      <td><strong>Time Travel</strong></td>
      <td>‚úÖ Query old versions</td>
    </tr>
    <tr>
      <td><strong>Updates</strong></td>
      <td>‚úÖ Efficient UPDATE/DELETE</td>
    </tr>
    <tr>
      <td><strong>Ecosystem</strong></td>
      <td>Databricks, Spark</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="apache-iceberg">Apache Iceberg</h3>

<p><strong>What it is:</strong> Netflix‚Äôs table format. Works with multiple engines.</p>

<div class="mermaid">
flowchart TD
    ICEBERG["Apache Iceberg"]
    
    ICEBERG --&gt; SPARK["Spark"]
    ICEBERG --&gt; FLINK["Flink"]
    ICEBERG --&gt; TRINO["Trino"]
    ICEBERG --&gt; PRESTO["Presto"]
    
    style ICEBERG fill:#dbeafe,stroke:#2563eb
    style SPARK fill:#d1fae5,stroke:#059669
    style FLINK fill:#d1fae5,stroke:#059669
    style TRINO fill:#d1fae5,stroke:#059669
    style PRESTO fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ACID</strong></td>
      <td>‚úÖ Yes</td>
    </tr>
    <tr>
      <td><strong>Hidden Partitioning</strong></td>
      <td>‚úÖ Auto-manages partitions</td>
    </tr>
    <tr>
      <td><strong>Schema Evolution</strong></td>
      <td>‚úÖ Safe column changes</td>
    </tr>
    <tr>
      <td><strong>Ecosystem</strong></td>
      <td>Engine-agnostic (Spark, Flink, Trino)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="apache-hudi">Apache Hudi</h3>

<p><strong>What it is:</strong> Uber‚Äôs table format. Optimized for streaming updates.</p>

<div class="mermaid">
flowchart LR
    subgraph hudi["Hudi Write Modes"]
        COW["Copy-on-Write<br />Fast reads"]
        MOR["Merge-on-Read<br />Fast writes"]
    end
    
    STREAM["Streaming<br />Updates"] --&gt; |"Choose mode"| hudi
    
    style COW fill:#dbeafe,stroke:#2563eb
    style MOR fill:#fef3c7,stroke:#d97706
    style STREAM fill:#d1fae5,stroke:#059669
</div>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ACID</strong></td>
      <td>‚úÖ Yes</td>
    </tr>
    <tr>
      <td><strong>Incremental Processing</strong></td>
      <td>‚úÖ Read only changes</td>
    </tr>
    <tr>
      <td><strong>Best For</strong></td>
      <td>Streaming data, frequent updates</td>
    </tr>
    <tr>
      <td><strong>Write Modes</strong></td>
      <td>Copy-on-Write, Merge-on-Read</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="delta-vs-iceberg-vs-hudi">Delta vs Iceberg vs Hudi</h3>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Delta Lake</th>
      <th>Iceberg</th>
      <th>Hudi</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ACID</strong></td>
      <td>‚úÖ</td>
      <td>‚úÖ</td>
      <td>‚úÖ</td>
    </tr>
    <tr>
      <td><strong>Time Travel</strong></td>
      <td>‚úÖ</td>
      <td>‚úÖ</td>
      <td>‚úÖ</td>
    </tr>
    <tr>
      <td><strong>Best Ecosystem</strong></td>
      <td>Databricks</td>
      <td>Multi-engine</td>
      <td>Spark streaming</td>
    </tr>
    <tr>
      <td><strong>Ease of Use</strong></td>
      <td>‚≠ê‚≠ê‚≠ê</td>
      <td>‚≠ê‚≠ê</td>
      <td>‚≠ê‚≠ê</td>
    </tr>
    <tr>
      <td><strong>Streaming</strong></td>
      <td>Good</td>
      <td>Good</td>
      <td>Excellent</td>
    </tr>
    <tr>
      <td><strong>Popularity</strong></td>
      <td>Most popular</td>
      <td>Growing fast</td>
      <td>Niche</td>
    </tr>
  </tbody>
</table>

<p><strong>Which to choose?</strong></p>
<ul>
  <li><strong>Delta Lake:</strong> Using Databricks or want easiest option</li>
  <li><strong>Iceberg:</strong> Need multi-engine support (Spark + Trino)</li>
  <li><strong>Hudi:</strong> Heavy streaming workloads</li>
</ul>

<hr />

<h2 id="decision-guide">Decision Guide</h2>

<div class="mermaid">
flowchart TD
    START["ü§î What are you storing?"]
    
    START --&gt; Q1{"File size?"}
    
    Q1 --&gt; |"&lt; 100 MB"| SMALL["Use CSV or JSON"]
    Q1 --&gt; |"&gt; 100 MB"| Q2
    
    Q2{"Need analytics?"}
    Q2 --&gt; |"Yes"| PARQUET["Use Parquet"]
    Q2 --&gt; |"No"| Q3
    
    Q3{"Need to share<br />with Excel?"}
    Q3 --&gt; |"Yes"| XLSX["Use XLSX"]
    Q3 --&gt; |"No"| Q4
    
    Q4{"Streaming data?"}
    Q4 --&gt; |"Yes"| AVRO["Use Avro"]
    Q4 --&gt; |"No"| Q5
    
    Q5{"Need ACID<br />transactions?"}
    Q5 --&gt; |"Yes"| DELTA["Use Delta Lake"]
    Q5 --&gt; |"No"| Q6
    
    Q6{"Human needs<br />to read it?"}
    Q6 --&gt; |"Yes"| JSON2["Use JSON/YAML"]
    Q6 --&gt; |"No"| PARQUET2["Use Parquet"]
    
    style START fill:#f1f5f9,stroke:#64748b
    style SMALL fill:#d1fae5,stroke:#059669
    style PARQUET fill:#fef3c7,stroke:#d97706
    style XLSX fill:#dbeafe,stroke:#2563eb
    style AVRO fill:#fce7f3,stroke:#db2777
    style DELTA fill:#e0e7ff,stroke:#6366f1
    style JSON2 fill:#d1fae5,stroke:#059669
    style PARQUET2 fill:#fef3c7,stroke:#d97706
</div>

<hr />

<h2 id="quick-reference-table">Quick Reference Table</h2>

<table>
  <thead>
    <tr>
      <th>Format</th>
      <th>Type</th>
      <th>Size</th>
      <th>Speed</th>
      <th>Best For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>CSV</strong></td>
      <td>Text</td>
      <td>Medium</td>
      <td>Medium</td>
      <td>Small datasets, Excel</td>
    </tr>
    <tr>
      <td><strong>JSON</strong></td>
      <td>Text</td>
      <td>Large</td>
      <td>Medium</td>
      <td>APIs, configs</td>
    </tr>
    <tr>
      <td><strong>XML</strong></td>
      <td>Text</td>
      <td>Very Large</td>
      <td>Slow</td>
      <td>Legacy systems</td>
    </tr>
    <tr>
      <td><strong>YAML</strong></td>
      <td>Text</td>
      <td>Medium</td>
      <td>Medium</td>
      <td>Config files</td>
    </tr>
    <tr>
      <td><strong>Parquet</strong></td>
      <td>Binary</td>
      <td>Small</td>
      <td>Very Fast</td>
      <td>Analytics, data warehouses</td>
    </tr>
    <tr>
      <td><strong>ORC</strong></td>
      <td>Binary</td>
      <td>Small</td>
      <td>Very Fast</td>
      <td>Hadoop/Hive</td>
    </tr>
    <tr>
      <td><strong>Avro</strong></td>
      <td>Binary</td>
      <td>Medium</td>
      <td>Fast</td>
      <td>Kafka, streaming</td>
    </tr>
    <tr>
      <td><strong>XLSX</strong></td>
      <td>Binary</td>
      <td>Medium</td>
      <td>Medium</td>
      <td>Excel, business reports</td>
    </tr>
    <tr>
      <td><strong>Pickle</strong></td>
      <td>Binary</td>
      <td>Small</td>
      <td>Fast</td>
      <td>Python-only temp storage</td>
    </tr>
    <tr>
      <td><strong>GZIP</strong></td>
      <td>Compressed</td>
      <td>Very Small</td>
      <td>Fast</td>
      <td>Any file compression</td>
    </tr>
    <tr>
      <td><strong>Delta Lake</strong></td>
      <td>Table</td>
      <td>Small</td>
      <td>Very Fast</td>
      <td>Data lake with ACID</td>
    </tr>
    <tr>
      <td><strong>Iceberg</strong></td>
      <td>Table</td>
      <td>Small</td>
      <td>Very Fast</td>
      <td>Multi-engine data lake</td>
    </tr>
    <tr>
      <td><strong>Hudi</strong></td>
      <td>Table</td>
      <td>Small</td>
      <td>Very Fast</td>
      <td>Streaming updates</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="common-combinations">Common Combinations</h2>

<p>Real-world data pipelines often use multiple formats:</p>

<div class="mermaid">
flowchart LR
    SOURCE["üì± App<br />JSON"] --&gt; KAFKA["üì¨ Kafka<br />Avro"]
    KAFKA --&gt; LANDING["üóÑÔ∏è Landing Zone<br />Parquet"]
    LANDING --&gt; LAKE["üåä Data Lake<br />Delta Lake"]
    LAKE --&gt; WAREHOUSE["‚ùÑÔ∏è Warehouse<br />Parquet"]
    WAREHOUSE --&gt; BI["üìä BI Tool<br />XLSX export"]
    
    style SOURCE fill:#dbeafe,stroke:#2563eb
    style KAFKA fill:#fce7f3,stroke:#db2777
    style LANDING fill:#fef3c7,stroke:#d97706
    style LAKE fill:#e0e7ff,stroke:#6366f1
    style WAREHOUSE fill:#d1fae5,stroke:#059669
    style BI fill:#dbeafe,stroke:#2563eb
</div>

<hr />

<h2 id="pro-tips">Pro Tips</h2>

<h3 id="1-start-simple">1. Start Simple</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CSV ‚Üí Parquet ‚Üí Delta Lake
</code></pre></div></div>
<p>Don‚Äôt jump to complex formats until you need them.</p>

<h3 id="2-compression-is-free">2. Compression is Free</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Always compress large files</span>
data.csv ‚Üí data.csv.gz  <span class="c"># 10x smaller</span>
</code></pre></div></div>

<h3 id="3-parquet-for-everything">3. Parquet for Everything</h3>
<p>If unsure, use Parquet. It‚Äôs fast, small, and widely supported.</p>

<h3 id="4-never-use-pickle-for-long-term-storage">4. Never Use Pickle for Long-Term Storage</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚ùå model.pkl  (can't read in 2 years)
‚úÖ model.json (always readable)
</code></pre></div></div>

<h3 id="5-match-format-to-tool">5. Match Format to Tool</h3>
<p>| Tool | Best Format |
|‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî-|
| Excel | XLSX, CSV |
| Pandas | Parquet, CSV |
| Spark | Parquet, Delta |
| Kafka | Avro |
| APIs | JSON |</p>

<hr />

<h2 id="summary">Summary</h2>

<div class="mermaid">
flowchart TD
    NEED["What do you need?"]
    
    NEED --&gt; SIMPLE["Keep it simple"] --&gt; CSV
    NEED --&gt; FAST["Fast analytics"] --&gt; PARQUET
    NEED --&gt; STREAM["Streaming"] --&gt; AVRO
    NEED --&gt; ACID["Transactions"] --&gt; DELTA
    NEED --&gt; SHARE["Share with others"] --&gt; XLSX
    NEED --&gt; CONFIG["Config files"] --&gt; YAML
    
    style NEED fill:#dbeafe,stroke:#2563eb
    style CSV fill:#d1fae5,stroke:#059669
    style PARQUET fill:#fef3c7,stroke:#d97706
    style AVRO fill:#fce7f3,stroke:#db2777
    style DELTA fill:#e0e7ff,stroke:#6366f1
    style XLSX fill:#dbeafe,stroke:#2563eb
    style YAML fill:#d1fae5,stroke:#059669
</div>

<p><strong>Remember:</strong> The best format is the one that solves your problem simply. Start with CSV or JSON, upgrade when you need speed or features!</p>

