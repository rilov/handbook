<h2 id="hashing">Hashing</h2>

<ul>
  <li>Hashing is a one-way function that produces a fixed-size digest from arbitrary input.</li>
  <li>Common algorithms: SHA-256, SHA-3, BLAKE2, MD5 (deprecated).</li>
  <li>Use-cases: password verification (with salt), data integrity checks, content-addressing (e.g., git), deduplication.</li>
  <li>Properties:
    <ul>
      <li>Deterministic: same input â†’ same digest.</li>
      <li>Irreversible: you cannot recover original data from the hash.</li>
      <li>Collision-resistant: hard to find two different inputs with same hash.</li>
    </ul>
  </li>
</ul>

<h2 id="encryption">Encryption</h2>

<ul>
  <li>Encryption is a reversible process to protect confidentiality; encrypted data can be decrypted if you have the key.</li>
  <li>Common algorithms: AES (symmetric), RSA &amp; Elliptic-Curve (asymmetric).</li>
  <li>Use-cases: protecting data at rest, data in transit (TLS), encrypted backups.</li>
  <li>Properties:
    <ul>
      <li>Reversible with the key.</li>
      <li>Requires secure key management.</li>
      <li>Can provide confidentiality and (with MACs) integrity.</li>
    </ul>
  </li>
</ul>

<h2 id="when-to-use-what">When to use what</h2>

<ul>
  <li>Use hashing when you only need to verify data or store a digest (e.g., passwords, checksums).</li>
  <li>Use encryption when you need to keep the original data secret but retrievable for authorized parties.</li>
</ul>

<h2 id="practical-tips">Practical tips</h2>

<ul>
  <li>For passwords, use a slow hashing algorithm with salt (bcrypt, scrypt, Argon2) rather than raw SHA-*.</li>
  <li>Always verify the authenticity/integrity of encrypted data (e.g. use authenticated encryption modes like AES-GCM).</li>
  <li>Properly manage keys and rotate them as needed when using encryption.</li>
</ul>

<h2 id="short-summary">Short Summary</h2>

<p>Hashing is for irreversible verification and identification; encryption is for reversible confidentiality using keys.</p>
